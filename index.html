<!DOCTYPE html>
<html>
  <head>
    <title></title>
  </head>
  <body>
  <script src="processing.js"></script>
<script type="text/processing" data-processing-target="processing-canvas">

String[] dimensions;
String[] entries;
float[][] data;
float[] xCoords;
float[][] yCoords;
float[][] invYs;
boolean[] isInverted;
float[] maxes;
float[] mins;
float rectWidth;
int coloredWith = 3;
boolean[] highlighted;

void setup() {
  size(400, 400);
  //surface.setResizable(true);
  background(255);
    rectMode(CENTER);

  loadData();
}

void draw() {
  background(255);
  drawBars();
  
  //checkHover();
  
}

void loadData() {
  String[] lines = loadStrings("data2.csv");
  
  String[] firstLine = split(lines[0], ",");
  dimensions = new String[firstLine.length - 1];
  for(int i = 0; i < dimensions.length; ++i) {
    dimensions[i] = firstLine[i+1];
  }
  //println(dimensions.length);
  
  //String[] restLines = new String[lines.length - 1];
  entries = new String[lines.length - 1];
  xCoords = new float[dimensions.length];
  maxes = new float[dimensions.length];
  mins = new float[dimensions.length];
  data = new float[dimensions.length][entries.length];
  yCoords = new float[dimensions.length][entries.length];
  invYs = new float[dimensions.length][entries.length];
  highlighted = new boolean[entries.length];

  isInverted = new boolean[dimensions.length];

  
  
  for(int i = 1; i < lines.length; ++i) {
    String[] line = split(lines[i], ",");

    entries[i-1] = line[0];
    for(int j = 1; j < line.length; ++j) {
      data[j-1][i-1] = parseFloat(line[j]);
    }
  }
  
 /* for(int i = 0; i < data.length; ++i) {
    for(int j = 0; j < data[0].length; ++j) {
      print(data[i][j] + " ");
    }
    println();
  }*/
  for(int dim = 0; dim < dimensions.length; ++dim) {
    mins[dim] = min(data[dim]);
    maxes[dim] = max(data[dim]);
  }
  
  
  
}

void drawBars() {
  float spacing = (.8*width)/(dimensions.length - 1);
  rectWidth = 0.01*width;
  for(int i = 0; i < dimensions.length; ++i) {
    float x = spacing*i + 0.1*width;
    xCoords[i] = x;
    float center = height/2;
    float h = 0.8*height;
    rectMode(CENTER);
    fill(255);
    rect(x, center, rectWidth, h);
    //line(x, .1*height, x, .9*height);  
  }
  
  fill(0);
  for(int i = 0; i < dimensions.length; ++i) {
    text(dimensions[i], xCoords[i], 0.99*height);
    if(i == coloredWith) fill(0);
    else fill(255);
    rect(xCoords[i], 0.075*height, 0.01*width, 0.03*height);
    fill(0);
    if(!isInverted[i]) {
      text(maxes[i], xCoords[i], 0.95*height);
      text(mins[i], xCoords[i], 0.05*height);
    }
    else {
      text(mins[i], xCoords[i], 0.95*height);
      text(maxes[i], xCoords[i], 0.05*height);
    }
  }
  
  
  for(int i = 0; i < dimensions.length; ++i) {
    for(int j = 0; j < entries.length; ++j ) {
      yCoords[i][j] = (0.1*height) + ((0.8*height)/(maxes[i] - mins[i]))*(data[i][j] - mins[i]);
      invYs[i][j] = height - yCoords[i][j];
    }
  }
  
  /*for(int i = 0; i < yCoords.length; ++i) {
    println(i);
    for(int j = 0; j < yCoords[0].length; ++j) {
      print(yCoords[i][j] + " ");
    }
    println();
  }*/
  
  
  for(int ent = 0; ent < entries.length; ++ent) {
    /*if(highlighted[ent]) {
      strokeWeight(4);
    }
    else {
      strokeWeight(1);
    }*/
    float red = ((yCoords[coloredWith][ent])/height)*255;
    float blue = 255 - red;
    stroke(red, 0, blue);
    for(int dimen = 0; dimen < dimensions.length - 1; ++dimen) {
      if(!isInverted[dimen] && !isInverted[dimen + 1]){
        line(xCoords[dimen], yCoords[dimen][ent], xCoords[dimen + 1], yCoords[dimen +1][ent]);
      }  
      else if (isInverted[dimen] && !isInverted[dimen + 1]){
        line(xCoords[dimen], invYs[dimen][ent], xCoords[dimen + 1], yCoords[dimen +1][ent]);
      }
      else if (isInverted[dimen] && isInverted[dimen + 1]){
        line(xCoords[dimen], invYs[dimen][ent], xCoords[dimen + 1], invYs[dimen +1][ent]);
      }
      else {
        line(xCoords[dimen], yCoords[dimen][ent], xCoords[dimen + 1], invYs[dimen +1][ent]);
      }
    }
  }

  
}

void mousePressed() {
  
  for(int i = 0; i < xCoords.length; ++i) {
    if( mouseY > 0.1*height && mouseY < 0.9*height && mouseX > (xCoords[i] - 0.5*rectWidth) && mouseX < (xCoords[i] + 0.5*rectWidth)) {
      
      isInverted[i] = !isInverted[i];
    }
    //rect(xCoords[i], 0.075*height, 0.01*width, 0.01*height);
    if( (mouseX > (xCoords[i] - 0.01*width)) && (mouseX < (xCoords[i] + 0.01*width)) && (mouseY > (0.075*height - 0.03*height)) && (mouseY < (0.075*height + 0.03*height))){
      coloredWith = i;
    }
  }
  
}

void checkHover() {
  for(int i = 0; i < highlighted.length; ++i) {
    highlighted[i] = false;
  }
  for(int i = 0; i < entries.length; ++i) {
    for(int j = 0; j < dimensions.length - 1; ++j) {
      PVector first = new PVector(xCoords[j], data[j][i]);
      PVector second = new PVector(xCoords[j+1], data[j+1][i]);
      PVector mouse = new PVector(mouseX, mouseY);
      if(pointInsideLine(mouse, first, second, 4)) {
        println("aaa");
        highlighted[i] = true;
        break;
      }
      else {
       // println("x");
      }
      
    }
  }
}

boolean pointInsideLine(PVector thePoint,
                        PVector theLineEndPoint1, 
                        PVector theLineEndPoint2, 
                        int theTolerance) {
                          
  PVector dir = new PVector(theLineEndPoint2.x,
                            theLineEndPoint2.y,
                            theLineEndPoint2.z);
  dir.sub(theLineEndPoint1);
  PVector diff = new PVector(thePoint.x, thePoint.y, 0);
  diff.sub(theLineEndPoint1);

  // inside distance determines the weighting 
  // between linePoint1 and linePoint2 
  float insideDistance = diff.dot(dir) / dir.dot(dir);

  if(insideDistance>0 && insideDistance<1) {
    // thePoint is inside/close to 
    // the line if insideDistance>0 or <1
    /*println( ((insideDistance<0.5) ? 
            "closer to p1":"closer to p2" ) + 
            "\t p1:"+nf((1-insideDistance),1,2)+
            " / p2:"+nf(insideDistance,1,2) );*/
            
    PVector closest = new PVector(theLineEndPoint1.x,
                                  theLineEndPoint1.y,
                                  theLineEndPoint1.z);
    dir.mult(insideDistance);
    closest.add(dir);
    PVector d = new PVector(thePoint.x, thePoint.y, 0);
    d.sub(closest);
     // println((insideDistance>0.5) ? "b":"a");
    float distsqr = d.dot(d);
    
    // check the distance of thePoint to the line against our tolerance. 
    return (distsqr < pow(theTolerance,2)); 
  }
  return false;
}

</script>
<canvas id="processing-canvas"> </canvas>
  
  </body>
</html>